להלן **הסבר ברור ומדויק** על ההבדל בין **Pass by Value** לבין **Pass by Reference**, בדגש על שפת **C**.

---

## Pass by Value – העברה לפי ערך

### מה זה אומר?

בעת קריאה לפונקציה:

* מועתק **הערך** של המשתנה
* הפונקציה עובדת על **עותק**
* שינויים בתוך הפונקציה **לא משפיעים** על המשתנה המקורי

### דוגמה ב־C

```c
void change(int x) {
    x = 10;
}

int main() {
    int a = 5;
    change(a);
    printf("%d\n", a);  // עדיין 5
}
```

📌 `a` לא משתנה כי `x` הוא עותק.

---

## Pass by Reference – העברה לפי כתובת

### מה זה אומר?

ב־C אין Pass by Reference “אמיתי”,
אבל משיגים את אותו אפקט ע״י **העברת מצביע**.

* מועברת **הכתובת** של המשתנה
* הפונקציה יכולה לשנות את הערך המקורי

### דוגמה ב־C

```c
void change(int *x) {
    *x = 10;
}

int main() {
    int a = 5;
    change(&a);
    printf("%d\n", a);  // 10
}
```

📌 כאן הערך של `a` משתנה, כי שינינו את התוכן שאליו המצביע מצביע.

---

## השוואה מסכמת

| Pass by Value     | Pass by Reference  |
| ----------------- | ------------------ |
| מועתק הערך        | מועברת הכתובת      |
| בטוח יותר         | מאפשר שינוי נתונים |
| לא משפיע על המקור | משפיע על המקור     |
| פשוט              | דורש מצביעים       |

---

## בהקשר של מערכים ב־C

כאשר מעבירים מערך לפונקציה:

* מועברת הכתובת שלו
* ולכן זה **כמו Pass by Reference**

```c
void fill(int arr[], int n) {
    arr[0] = 99;
}
```

---

## נקודת מבחן חשובה

> ב־C כל הפרמטרים מועברים **בערך**,
> אך כאשר מעבירים מצביע – הערך הוא כתובת, ולכן ניתן לשנות את הנתון המקורי.

---

## משפט קצר למבחן

> ב־Pass by Value מועתק ערך המשתנה לפונקציה ולכן שינויים אינם משפיעים על המקור, בעוד שב־Pass by Reference מועברת כתובת המשתנה, דבר המאפשר לפונקציה לשנות את הערך המקורי.
