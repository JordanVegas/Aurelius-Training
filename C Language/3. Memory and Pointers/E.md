להלן **התשובה המסודרת והמדויקת**, כולל הסבר על `sizeof`, וטבלה ל־**32bit** ו־**64bit** (כפי שמקובל בלינוקס עם GCC).

---

## הפעולה `sizeof`

ה־`sizeof` היא **אופרטור** (לא פונקציה) שמחזיר:

* את **גודל הטיפוס או המשתנה בבתים**
* הערך נקבע בזמן **קומפילציה**
* התוצאה היא מסוג `size_t`

דוגמה:

```c
printf("%zu\n", sizeof(int));
```

---

## גדלי טיפוסים ב־C (מערכות נפוצות)

⚠️ חשוב: התקן של C **לא מחייב גדלים מדויקים**, אך בפועל קיימת מוסכמה ברורה.

---

## מערכת 32 ביט (ILP32)

| טיפוס          | גודל (בתים) |
| -------------- | ----------- |
| `char`         | 1           |
| `int`          | 4           |
| `unsigned int` | 4           |
| `long`         | 4           |

---

## מערכת 64 ביט (LP64 – לינוקס, macOS)

| טיפוס          | גודל (בתים) |
| -------------- | ----------- |
| `char`         | 1           |
| `int`          | 4           |
| `unsigned int` | 4           |
| `long`         | 8           |

📌 שים לב:

* `int` **לא משתנה** בין 32 ל־64 ביט
* `long` כן משתנה

---

## למה זה ככה?

* `char` תמיד 1 byte (עפ״י התקן)
* `int` מיועד להיות “טבעי ומהיר” למעבד
* `long` מותאם לגודל כתובות במערכת
* `unsigned int` זהה בגודל ל־`int`, רק ללא ביט סימן

---

## בדיקה בפועל עם `sizeof`

```c
#include <stdio.h>

int main() {
    printf("char: %zu\n", sizeof(char));
    printf("int: %zu\n", sizeof(int));
    printf("unsigned int: %zu\n", sizeof(unsigned int));
    printf("long: %zu\n", sizeof(long));
    return 0;
}
```

---

## נקודות חשובות למבחן

✔ `sizeof` מחזיר גודל בבתים
✔ `char` תמיד 1
✔ `int` = 4 בייט (בפועל)
✔ `long` = 4 ב־32bit, 8 ב־64bit
✔ `unsigned int` זהה בגודל ל־`int`

---